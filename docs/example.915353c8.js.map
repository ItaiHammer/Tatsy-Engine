{"version":3,"sources":["engine/engine.js","animation1.js","example.js"],"names":["scene","canvas","document","createElement","elements","clear","context","clearRect","width","height","start","data","getContext","handleColor","color","drawRect","push","Rect","name","positionX","positionY","sizeX","sizeY","update","position","x","y","size","fillStyle","draw","fillRect","forEach","element","drawPath","Path","startPos","paths","beginPath","moveTo","path","lineTo","strokeStyle","stroke","drawArc","drawCounterClockWise","Arc","radius","startAng","endAng","fill","arc","findElementByName","foundElement","i","startAnimation","frameRate","animation","setInterval","sceneParent","append","animation1","body","innerWidth","innerHeight","mouse","colorArray","window","addEventListener","e","ballCount","vx","Math","random","vy","minRadius","maxRadius","PI","floor","length","animations","onload"],"mappings":";AAuOeA,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EAvOf,IAAIA,EAAQ,CACRC,OAAQC,SAASC,cAAc,UAC/BC,SAAU,GACVC,MAAO,WACHL,EAAMM,QAAQC,UAAU,EAAG,EAAGP,EAAMC,OAAOO,MAAOR,EAAMC,OAAOQ,SAEnEC,MAAO,SAACC,GAEc,MAAdA,EAAKH,QACLR,EAAMC,OAAOO,MAAQG,EAAKH,OAEX,MAAfG,EAAKF,SACLT,EAAMC,OAAOQ,OAASE,EAAKF,QAE/BT,EAAMM,QAAUN,EAAMC,OAAOW,WAAW,MAClCN,IAAAA,EAAUN,EAAMM,QAItBN,EAAMa,YAAc,SAACC,GACVA,OAAS,MAATA,GAA2B,KAAVA,EAAe,QAAUA,GAE/CD,IAAAA,EAAcb,EAAMa,YAI1Bb,EAAMe,SAAW,SAACJ,GAkCdX,EAAMI,SAASY,KACX,IAlCKC,SACLC,EACAC,EACAC,EACAC,EACAC,EACAR,EACAS,GACF,IAAA,EAAA,KACOL,KAAAA,KAAOA,EACPM,KAAAA,SAAW,CAAEC,EAAGN,EAAWO,EAAGN,GAC9BO,KAAAA,KAAO,CAAEF,EAAGJ,EAAOK,EAAGJ,GACtBR,KAAAA,MAAQD,EAAYF,EAAKG,OAE9BR,EAAQsB,UAAY,KAAKd,MAEpBe,KAAAA,KAAO,WACRvB,EAAQwB,SACJ,EAAKN,SAASC,EACd,EAAKD,SAASE,EACd,EAAKC,KAAKF,EACV,EAAKE,KAAKD,IAIbH,KAAAA,OACS,MAAVA,EACM,WACI,EAAKM,QAETN,EAIV,CACIZ,EAAKO,KACLP,EAAKa,SAASC,EACdd,EAAKa,SAASE,EACdf,EAAKgB,KAAKF,EACVd,EAAKgB,KAAKD,EACVf,EAAKG,MACLH,EAAKY,SAKbvB,EAAMI,SAAS2B,QAAQ,SAACC,GAAYA,OAAAA,EAAQH,UAIhD7B,EAAMiC,SAAW,SAACtB,GAEdA,EAAKG,MAAQD,EAAYF,EAAKG,OA4B9Bd,EAAMI,SAASY,KACX,IA3BKkB,SAAKhB,EAAMiB,EAAUC,EAAOtB,EAAOS,GAAQ,IAAA,EAAA,KAC3CL,KAAAA,KAAOA,EACPiB,KAAAA,SAAWA,EACXC,KAAAA,MAAQA,EACRtB,KAAAA,MAAQA,EAERe,KAAAA,KAAO,WACRvB,EAAQ+B,YACR/B,EAAQgC,OAAOH,EAASV,EAAGU,EAAST,GACpCf,EAAKyB,MAAML,QAAQ,SAACQ,GAChBjC,EAAQkC,OAAOD,EAAKd,EAAGc,EAAKb,KAGhCpB,EAAQmC,YAAc3B,EAEtBR,EAAQoC,UAGPnB,KAAAA,OACS,MAAVA,EACM,WACI,EAAKM,QAETN,EAIV,CACIZ,EAAKO,KACLP,EAAKwB,SACLxB,EAAKyB,MACLzB,EAAKG,MACLH,EAAKY,SAKbvB,EAAMI,SAAS2B,QAAQ,SAACC,GAAYA,OAAAA,EAAQH,UAIhD7B,EAAM2C,QAAU,SAAChC,GACbA,EAAKiC,qBAC4B,MAA7BjC,EAAKiC,sBAECjC,EAAKiC,qBAkDf5C,EAAMI,SAASY,KACX,IAjDK6B,SACL3B,EACAM,EACAsB,EACAC,EACAC,EACAJ,EACA9B,EACAmC,EACA1B,GACF,IAAA,EAAA,KACOL,KAAAA,KAAOA,EACPM,KAAAA,SAAWA,EACXsB,KAAAA,OAASA,EACTC,KAAAA,SAAWA,EACXC,KAAAA,OAASA,EACTJ,KAAAA,qBAAuBA,EACvB9B,KAAAA,MAAQA,EACRmC,KAAAA,KAAOA,EAEPpB,KAAAA,KAAO,WACRvB,EAAQ+B,YACR/B,EAAQ4C,IACJ,EAAK1B,SAASC,EACd,EAAKD,SAASE,EACd,EAAKoB,OACL,EAAKC,SACL,EAAKC,OACL,EAAKJ,sBAES,MAAd,EAAK9B,QACLR,EAAQmC,YAAc,EAAK3B,MAC3BR,EAAQoC,UAEK,MAAb,EAAKO,OACL3C,EAAQsB,UAAY,EAAKqB,KACzB3C,EAAQ2C,SAIX1B,KAAAA,OACS,MAAVA,EACM,WACI,EAAKM,QAETN,EAIV,CACIZ,EAAKO,KACLP,EAAKa,SACLb,EAAKmC,OACLnC,EAAKoC,SACLpC,EAAKqC,OACLrC,EAAKiC,qBACLjC,EAAKG,MACLH,EAAKsC,KACLtC,EAAKY,SAKbvB,EAAMmD,kBAAoB,SAACjC,GACnBkC,IAAAA,GAAe,EACfC,EAAI,EAUJD,OARJpD,EAAMI,SAAS2B,QAAQ,SAACC,GAChBA,EAAQd,OAASA,EACjBkC,GAAe,GACS,IAAjBA,GACPC,OAIa,IAAjBD,EACOpD,EAAMI,SAASiD,GAEf,MAKfrD,EAAMI,SAAS2B,QAAQ,SAACC,GAAYA,OAAAA,EAAQH,UAIhD7B,EAAMsD,eAAiB,SAACC,EAAWC,GAC/BC,YAAY,WACRzD,EAAMK,QACW,MAAbmD,GACAA,IAGJxD,EAAMI,SAAS2B,QAAQ,SAACC,GAAYA,OAAAA,EAAQT,OAAOS,MACpD,IAAOuB,IAId5C,EAAK+C,YAAYC,OAAO3D,EAAMC,UAIvBD,EAAAA,EAAAA,QAAAA,QAAAA;;ACvJA4D,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EAhFf,IAAA,EAAA,EAAA,QAAA,uBAgFeA,SAAAA,EAAAA,GAAAA,OAAAA,GAAAA,EAAAA,WAAAA,EAAAA,CAAAA,QAAAA,GA9Ef,SAASA,IACClD,EAAAA,QAAAA,MAAM,CACRgD,YAAaxD,SAAS2D,KACtBrD,MAAOsD,WACPrD,OAAQsD,cAGRC,IAAAA,EAAQ,CACRvC,GAAI,IACJC,GAAI,KAGFuC,EAAa,CAAC,UAAW,UAAW,UAAW,UAAW,WAEhEC,OAAOC,iBAAiB,YAAa,SAACC,GAClCJ,EAAMvC,EAAI2C,EAAE3C,EACZuC,EAAMtC,EAAI0C,EAAE1C,IAKX,IAFC2C,IAEGhB,EAAAA,SAAAA,GACDiB,IAAAA,EAA6B,GAAvBC,KAAKC,SAAW,IACtBC,EAA6B,GAAvBF,KAAKC,SAAW,IACtBE,EAA4B,EAAhBH,KAAKC,SAAe,EAChCG,EAA4B,GAAhBJ,KAAKC,SAAgB,GAG/B7B,EAAAA,QAAAA,QAAQ,CACVnB,SAAU,CACNC,EAAG8C,KAAKC,SAAWxE,EAAMC,QAAAA,OAAOO,MAAQ,GACxCkB,EAAG6C,KAAKC,SAAWxE,EAAMC,QAAAA,OAAOQ,OAAS,IAE7CqC,OAAQ4B,EACR3B,SAAU,EACVC,OAAkB,EAAVuB,KAAKK,GACb3B,KAAMgB,EAAWM,KAAKM,MAAMN,KAAKC,SAAWP,EAAWa,SACvDvD,OAAQ,SAACS,IAEDA,EAAQR,SAASC,EAAIO,EAAQc,OAAS9C,EAAMC,QAAAA,OAAOO,OACnDwB,EAAQR,SAASC,EAAIO,EAAQc,OAAS,KAEtCwB,GAAMA,IAGNtC,EAAQR,SAASE,EAAIM,EAAQc,OAAS9C,EAAMC,QAAAA,OAAOQ,QACnDuB,EAAQR,SAASE,EAAIM,EAAQc,OAAS,KAEtC2B,GAAMA,GAGVzC,EAAQR,SAASC,GAAK6C,EACtBtC,EAAQR,SAASE,GAAK+C,EAIlBT,EAAMvC,EAAIO,EAAQR,SAASC,EA9Bb,IA+BduC,EAAMvC,EAAIO,EAAQR,SAASC,GA/Bb,IAgCduC,EAAMtC,EAAIM,EAAQR,SAASE,EAhCb,IAiCdsC,EAAMtC,EAAIM,EAAQR,SAASE,GAjCb,IAkCdM,EAAQc,OAAS6B,EAEjB3C,EAAQc,SACDd,EAAQc,OAAS4B,GACxB1C,EAAQc,SAGZd,EAAQH,WA9CXwB,EAAI,EAFK,KAEUA,EAAGA,IAAtBA,IAmDHC,EAAAA,QAAAA,eAAe,GAAI,WACfrD,EAAAA,QAAAA,OAAOO,MAAQsD,WACf7D,EAAAA,QAAAA,OAAOQ,OAASsD,cAIfH,IAAAA,EAAAA,EAAAA,QAAAA,QAAAA;;AC5Ef,aAJA,IAAA,EAAA,EAAA,QAAA,oBAIA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAFA,IAAMmB,EAAa,CAACnB,EAAD,SAEnBM,OAAOc,OAAS,WACZD,OAAAA,EAAWR,KAAKM,MAAMN,KAAKC,SAAWO,EAAWD","file":"example.915353c8.js","sourceRoot":"..","sourcesContent":["let scene = {\r\n    canvas: document.createElement('canvas'),\r\n    elements: [],\r\n    clear: () => {\r\n        scene.context.clearRect(0, 0, scene.canvas.width, scene.canvas.height);\r\n    },\r\n    start: (data) => {\r\n        //setting up canvas\r\n        if (data.width != null) {\r\n            scene.canvas.width = data.width;\r\n        }\r\n        if (data.height != null) {\r\n            scene.canvas.height = data.height;\r\n        }\r\n        scene.context = scene.canvas.getContext('2d');\r\n        const context = scene.context;\r\n\r\n        //handling functions\r\n\r\n        scene.handleColor = (color) => {\r\n            return color == null || color === '' ? 'black' : color;\r\n        };\r\n        const handleColor = scene.handleColor;\r\n\r\n        //drawing functions\r\n        //drawing rectangle\r\n        scene.drawRect = (data) => {\r\n            function Rect(\r\n                name,\r\n                positionX,\r\n                positionY,\r\n                sizeX,\r\n                sizeY,\r\n                color,\r\n                update\r\n            ) {\r\n                this.name = name;\r\n                this.position = { x: positionX, y: positionY };\r\n                this.size = { x: sizeX, y: sizeY };\r\n                this.color = handleColor(data.color);\r\n\r\n                context.fillStyle = this.color;\r\n\r\n                this.draw = () => {\r\n                    context.fillRect(\r\n                        this.position.x,\r\n                        this.position.y,\r\n                        this.size.x,\r\n                        this.size.y\r\n                    );\r\n                };\r\n\r\n                this.update =\r\n                    update == null\r\n                        ? () => {\r\n                              this.draw();\r\n                          }\r\n                        : update;\r\n            }\r\n\r\n            scene.elements.push(\r\n                new Rect(\r\n                    data.name,\r\n                    data.position.x,\r\n                    data.position.y,\r\n                    data.size.x,\r\n                    data.size.y,\r\n                    data.color,\r\n                    data.update\r\n                )\r\n            );\r\n\r\n            //drawing everything on the scene\r\n            scene.elements.forEach((element) => element.draw());\r\n        };\r\n\r\n        //drawing line\r\n        scene.drawPath = (data) => {\r\n            //handling color\r\n            data.color = handleColor(data.color);\r\n\r\n            function Path(name, startPos, paths, color, update) {\r\n                this.name = name;\r\n                this.startPos = startPos;\r\n                this.paths = paths;\r\n                this.color = color;\r\n\r\n                this.draw = () => {\r\n                    context.beginPath();\r\n                    context.moveTo(startPos.x, startPos.y);\r\n                    data.paths.forEach((path) => {\r\n                        context.lineTo(path.x, path.y);\r\n                    });\r\n\r\n                    context.strokeStyle = color;\r\n\r\n                    context.stroke();\r\n                };\r\n\r\n                this.update =\r\n                    update == null\r\n                        ? () => {\r\n                              this.draw();\r\n                          }\r\n                        : update;\r\n            }\r\n\r\n            scene.elements.push(\r\n                new Path(\r\n                    data.name,\r\n                    data.startPos,\r\n                    data.paths,\r\n                    data.color,\r\n                    data.update\r\n                )\r\n            );\r\n\r\n            //drawing everything on the scene\r\n            scene.elements.forEach((element) => element.draw());\r\n        };\r\n\r\n        //drawing arc\r\n        scene.drawArc = (data) => {\r\n            data.drawCounterClockWise =\r\n                data.drawCounterClockWise == null\r\n                    ? false\r\n                    : data.drawCounterClockWise;\r\n\r\n            function Arc(\r\n                name,\r\n                position,\r\n                radius,\r\n                startAng,\r\n                endAng,\r\n                drawCounterClockWise,\r\n                color,\r\n                fill,\r\n                update\r\n            ) {\r\n                this.name = name;\r\n                this.position = position;\r\n                this.radius = radius;\r\n                this.startAng = startAng;\r\n                this.endAng = endAng;\r\n                this.drawCounterClockWise = drawCounterClockWise;\r\n                this.color = color;\r\n                this.fill = fill;\r\n\r\n                this.draw = () => {\r\n                    context.beginPath();\r\n                    context.arc(\r\n                        this.position.x,\r\n                        this.position.y,\r\n                        this.radius,\r\n                        this.startAng,\r\n                        this.endAng,\r\n                        this.drawCounterClockWise\r\n                    );\r\n                    if (this.color != null) {\r\n                        context.strokeStyle = this.color;\r\n                        context.stroke();\r\n                    }\r\n                    if (this.fill != null) {\r\n                        context.fillStyle = this.fill;\r\n                        context.fill();\r\n                    }\r\n                };\r\n\r\n                this.update =\r\n                    update == null\r\n                        ? () => {\r\n                              this.draw();\r\n                          }\r\n                        : update;\r\n            }\r\n\r\n            scene.elements.push(\r\n                new Arc(\r\n                    data.name,\r\n                    data.position,\r\n                    data.radius,\r\n                    data.startAng,\r\n                    data.endAng,\r\n                    data.drawCounterClockWise,\r\n                    data.color,\r\n                    data.fill,\r\n                    data.update\r\n                )\r\n            );\r\n\r\n            //finding functions\r\n            scene.findElementByName = (name) => {\r\n                let foundElement = false;\r\n                let i = 0;\r\n\r\n                scene.elements.forEach((element) => {\r\n                    if (element.name === name) {\r\n                        foundElement = true;\r\n                    } else if (foundElement === false) {\r\n                        i++;\r\n                    }\r\n                });\r\n\r\n                if (foundElement === true) {\r\n                    return scene.elements[i];\r\n                } else {\r\n                    return null;\r\n                }\r\n            };\r\n\r\n            //drawing everything on the scene\r\n            scene.elements.forEach((element) => element.draw());\r\n        };\r\n\r\n        //animation functions\r\n        scene.startAnimation = (frameRate, animation) => {\r\n            setInterval(() => {\r\n                scene.clear();\r\n                if (animation != null) {\r\n                    animation();\r\n                }\r\n                //drawing everything on the scene\r\n                scene.elements.forEach((element) => element.update(element));\r\n            }, 1000 / frameRate);\r\n        };\r\n\r\n        //appending canvas into the DOM\r\n        data.sceneParent.append(scene.canvas);\r\n    },\r\n};\r\n\r\nexport default scene;\r\n","import scene from './engine/engine.js';\r\n\r\nfunction animation1() {\r\n    scene.start({\r\n        sceneParent: document.body,\r\n        width: innerWidth,\r\n        height: innerHeight,\r\n    });\r\n\r\n    let mouse = {\r\n        x: -100,\r\n        y: -100,\r\n    };\r\n\r\n    const colorArray = ['#d9d2ea', '#4c0490', '#36026a', '#6206b6', '#7b6b92'];\r\n\r\n    window.addEventListener('mousemove', (e) => {\r\n        mouse.x = e.x;\r\n        mouse.y = e.y;\r\n    });\r\n\r\n    const ballCount = 1500;\r\n\r\n    for (let i = 0; ballCount > i; i++) {\r\n        let vx = (Math.random() - 0.5) * 2;\r\n        let vy = (Math.random() - 0.5) * 2;\r\n        let minRadius = Math.random() * 6 + 2;\r\n        let maxRadius = Math.random() * 30 + 20;\r\n        let interactionDistance = 50;\r\n\r\n        scene.drawArc({\r\n            position: {\r\n                x: Math.random() * scene.canvas.width - 30,\r\n                y: Math.random() * scene.canvas.height - 30,\r\n            },\r\n            radius: minRadius,\r\n            startAng: 0,\r\n            endAng: Math.PI * 2,\r\n            fill: colorArray[Math.floor(Math.random() * colorArray.length)],\r\n            update: (element) => {\r\n                if (\r\n                    element.position.x + element.radius > scene.canvas.width ||\r\n                    element.position.x - element.radius < 0\r\n                ) {\r\n                    vx = -vx;\r\n                }\r\n                if (\r\n                    element.position.y + element.radius > scene.canvas.height ||\r\n                    element.position.y - element.radius < 0\r\n                ) {\r\n                    vy = -vy;\r\n                }\r\n\r\n                element.position.x += vx;\r\n                element.position.y += vy;\r\n\r\n                //interaction\r\n                if (\r\n                    mouse.x - element.position.x < interactionDistance &&\r\n                    mouse.x - element.position.x > -interactionDistance &&\r\n                    mouse.y - element.position.y < interactionDistance &&\r\n                    mouse.y - element.position.y > -interactionDistance &&\r\n                    element.radius < maxRadius\r\n                ) {\r\n                    element.radius++;\r\n                } else if (element.radius > minRadius) {\r\n                    element.radius--;\r\n                }\r\n\r\n                element.draw();\r\n            },\r\n        });\r\n    }\r\n\r\n    scene.startAnimation(60, () => {\r\n        scene.canvas.width = innerWidth;\r\n        scene.canvas.height = innerHeight;\r\n    });\r\n}\r\n\r\nexport default animation1;\r\n","import animation1 from './animation1.js';\r\n\r\nconst animations = [animation1];\r\n\r\nwindow.onload = () =>\r\n    animations[Math.floor(Math.random() * animations.length)]();\r\n"]}